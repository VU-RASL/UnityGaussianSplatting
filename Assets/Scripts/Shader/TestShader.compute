#pragma kernel CalcFacesTransform
#pragma kernel MapGaussiansToFaces

// Constants for scaling activation
#define MIN_S_VALUE 0.0f
#define MAX_S_VALUE 0.1f

// Buffers
StructuredBuffer<float3> VertexBuffer;       // Vertex positions
StructuredBuffer<int3> FaceBuffer;          // Faces (indices of vertices)
StructuredBuffer<int> GaussianToFaceBuffer; // Mapping from Gaussian to face indices
StructuredBuffer<float3> HahaXyzBuffer;     // Original Gaussian positions
StructuredBuffer<float4> HahaRotationBuffer; // Original Gaussian rotations
StructuredBuffer<float> HahaScalingBuffer;  // Original Gaussian scaling
RWStructuredBuffer<float3> TBuffer;         // Translations (output)
RWStructuredBuffer<float4> RBuffer;         // Rotations as quaternions (output)
RWStructuredBuffer<float> kBuffer;          // Scaling factors (output)

// Combined Gaussian-specific buffer
struct GaussianData
{

    float4 rotation;    
    float3 scaling;      
};
RWStructuredBuffer<GaussianData> GaussianDataBuffer; // Combined buffer

RWStructuredBuffer<float3> UpdatedXyzBuffer;    // Updated Gaussian positions

// Constants
#define MAX_SCALE 0.05

// Function to compute quaternion from a 3x3 rotation matrix
float4 MatrixToQuaternion(float3x3 m)
{
    float4 q;
    float trace = m[0][0] + m[1][1] + m[2][2]; // Sum of diagonal elements

    float q_abs[4];
    q_abs[0] = sqrt(max(0.0, 1.0 + m[0][0] + m[1][1] + m[2][2]));
    q_abs[1] = sqrt(max(0.0, 1.0 + m[0][0] - m[1][1] - m[2][2]));
    q_abs[2] = sqrt(max(0.0, 1.0 - m[0][0] + m[1][1] - m[2][2]));
    q_abs[3] = sqrt(max(0.0, 1.0 - m[0][0] - m[1][1] + m[2][2]));

    float4 quat_candidates[4];
    quat_candidates[0] = float4(q_abs[0] * 0.5, (m[2][1] - m[1][2]) / (2.0 * q_abs[0]), (m[0][2] - m[2][0]) / (2.0 * q_abs[0]), (m[1][0] - m[0][1]) / (2.0 * q_abs[0]));
    quat_candidates[1] = float4((m[2][1] - m[1][2]) / (2.0 * q_abs[1]), q_abs[1] * 0.5, (m[1][0] + m[0][1]) / (2.0 * q_abs[1]), (m[0][2] + m[2][0]) / (2.0 * q_abs[1]));
    quat_candidates[2] = float4((m[0][2] - m[2][0]) / (2.0 * q_abs[2]), (m[1][0] + m[0][1]) / (2.0 * q_abs[2]), q_abs[2] * 0.5, (m[2][1] + m[1][2]) / (2.0 * q_abs[2]));
    quat_candidates[3] = float4((m[1][0] - m[0][1]) / (2.0 * q_abs[3]), (m[0][2] + m[2][0]) / (2.0 * q_abs[3]), (m[2][1] + m[1][2]) / (2.0 * q_abs[3]), q_abs[3] * 0.5);

    // Find the best quaternion candidate (numerically stable, largest q_abs)
    int max_index = 0;
    float max_value = q_abs[0];
    for (int i = 1; i < 4; i++)
    {
        if (q_abs[i] > max_value)
        {
            max_index = i;
            max_value = q_abs[i];
        }
    }

    q = quat_candidates[max_index];
    return normalize(q);
}


// Helper function: Apply quaternion to vector
float3 quaternion_apply(float4 q, float3 v)
{
    float3 u = float3(q.x, q.y, q.z);
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

// Scaling activation function
float3 s_act(float3 x)
{
    return MIN_S_VALUE + saturate(1.0 / (1.0 + exp(-x))) * (MAX_S_VALUE - MIN_S_VALUE);
}

// Kernel: Compute translations, rotations, and scaling factors for faces
[numthreads(64, 1, 1)]
void CalcFacesTransform(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= FaceBuffer.Length)
        return;

    // Load face vertex indices
    // int3 face = FaceBuffer[id.x];
    int faceIndex = GaussianToFaceBuffer[id.x];  // Map Gaussian to face index
    int3 face = FaceBuffer[faceIndex];  
    // Get face vertices
    float3 v0 = VertexBuffer[face.x];
    float3 v1 = VertexBuffer[face.y];
    float3 v2 = VertexBuffer[face.z];

    // Calculate translation (T): Mean of vertices
    float3 T = (v0 + v1 + v2) / 3.0f;
    TBuffer[id.x] = T;

    // Calculate vectors for face edges
    // float3 vec1 = normalize(v1 - v0);
    // float3 vec2 = normalize(v2 - v0);
    float3 vec1 = v2 - v1;
    float3 vec2 = v0 - v1;
    float3 vec3 = v0 - v2;

    // Calculate normal and orthonormal basis
    float3 v12cross = cross(vec1,vec2);
    float3 norm = normalize(v12cross);
    vec1 = normalize(vec1);
    float3 prod = normalize(cross(vec1, norm));

    // Build rotation matrix
    float3x3 rotmat = float3x3(vec1, norm, prod);
    rotmat = transpose(rotmat);

    // Convert rotation matrix to quaternion (R)
    // float4 R = normalize(float4(rotmat[0][0], rotmat[0][1], rotmat[0][2], 0.0));
    float4 R = MatrixToQuaternion(rotmat);
    RBuffer[id.x] = R;

    // Calculate area and edge lengths for scaling factor (k)
    float area = length(v12cross);
    float vec3_length = length(vec3);
    float h = area / vec3_length;

    float k = (h + vec3_length) / (2.0 * MAX_SCALE);
    kBuffer[id.x] = k;
}

// Kernel: Map Gaussian attributes and update positions
[numthreads(64, 1, 1)]
void MapGaussiansToFaces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GaussianToFaceBuffer.Length)
        return;

    // Get the face index corresponding to this Gaussian
    int faceIndex = GaussianToFaceBuffer[id.x];

    // Map T, R, k for this Gaussian
    // float3 T = TBuffer[faceIndex];
    // float4 R = RBuffer[faceIndex];
    // float k = kBuffer[faceIndex];
    float3 T = TBuffer[id.x];
    float4 R = RBuffer[id.x];
    float k = kBuffer[id.x];
    // Normalize rotation and compute rigid rotation
    float4 originalRotation = HahaRotationBuffer[id.x];
    originalRotation = normalize(originalRotation);
    float4 rigidRotation = normalize(float4(
        R.w * originalRotation.x + R.x * originalRotation.w + R.y * originalRotation.z - R.z * originalRotation.y,
        R.w * originalRotation.y - R.x * originalRotation.z + R.y * originalRotation.w + R.z * originalRotation.x,
        R.w * originalRotation.z + R.x * originalRotation.y - R.y * originalRotation.x + R.z * originalRotation.w,
        R.w * originalRotation.w - R.x * originalRotation.x - R.y * originalRotation.y - R.z * originalRotation.z
    ));

    float3 scaling = HahaScalingBuffer[id.x];
    float3 adjustedScaling = s_act(scaling) * k;

    // Compute updated position
    float3 originalXyz = HahaXyzBuffer[id.x];
    float3 updatedXyz = T + quaternion_apply(rigidRotation, originalXyz) * adjustedScaling;

    // Write to combined buffer
    GaussianData data;
    data.rotation = rigidRotation;
    data.scaling = adjustedScaling;
    GaussianDataBuffer[id.x] = data;

    // Write updated position
    UpdatedXyzBuffer[id.x] = updatedXyz;
}
