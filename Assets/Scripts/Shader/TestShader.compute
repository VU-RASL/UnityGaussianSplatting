#pragma kernel CalcFacesTransform
#pragma kernel MapGaussiansToFaces

// Constants for scaling activation
#define MIN_S_VALUE 0.0f
#define MAX_S_VALUE 0.1f

// Buffers
StructuredBuffer<float3> VertexBuffer;       // Vertex positions
StructuredBuffer<int3> FaceBuffer;          // Faces (indices of vertices)
StructuredBuffer<int> GaussianToFaceBuffer; // Mapping from Gaussian to face indices
StructuredBuffer<float3> HahaXyzBuffer;     // Original Gaussian positions
StructuredBuffer<float4> HahaRotationBuffer; // Original Gaussian rotations
StructuredBuffer<float> HahaScalingBuffer;  // Original Gaussian scaling
RWStructuredBuffer<float3> TBuffer;         // Translations (output)
RWStructuredBuffer<float4> RBuffer;         // Rotations as quaternions (output)
RWStructuredBuffer<float> kBuffer;          // Scaling factors (output)

// Combined Gaussian-specific buffer
struct GaussianData
{

    float4 rotation;    
    float3 scaling;      
};
RWStructuredBuffer<GaussianData> GaussianDataBuffer; // Combined buffer

RWStructuredBuffer<float3> UpdatedXyzBuffer;    // Updated Gaussian positions

// Constants
#define MAX_SCALE 0.05

// Helper function: Normalize a quaternion
float4 q_normalize(float4 q)
{
    float norm = sqrt(dot(q, q));
    return q / norm;
}

// Helper function: Apply quaternion to vector
float3 quaternion_apply(float4 q, float3 v)
{
    float3 u = float3(q.x, q.y, q.z);
    float s = q.w;

    return 2.0 * dot(u, v) * u
         + (s * s - dot(u, u)) * v
         + 2.0 * s * cross(u, v);
}

// Scaling activation function
float3 s_act(float3 x)
{
    return MIN_S_VALUE + saturate(1.0 / (1.0 + exp(-x))) * (MAX_S_VALUE - MIN_S_VALUE);
}

// Kernel: Compute translations, rotations, and scaling factors for faces
[numthreads(64, 1, 1)]
void CalcFacesTransform(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= FaceBuffer.Length)
        return;

    // Load face vertex indices
    // int3 face = FaceBuffer[id.x];
    int faceIndex = GaussianToFaceBuffer[id.x];  // Map Gaussian to face index
    int3 face = FaceBuffer[faceIndex];  
    // Get face vertices
    float3 v0 = VertexBuffer[face.x];
    float3 v1 = VertexBuffer[face.y];
    float3 v2 = VertexBuffer[face.z];

    // Calculate translation (T): Mean of vertices
    float3 T = (v0 + v1 + v2) / 3.0f;
    TBuffer[id.x] = T;

    // Calculate vectors for face edges
    float3 vec1 = normalize(v1 - v0);
    float3 vec2 = normalize(v2 - v0);

    // Calculate normal and orthonormal basis
    float3 normal = normalize(cross(vec1, vec2));
    float3 prod = normalize(cross(vec1, normal));

    // Build rotation matrix
    float3x3 rotmat = float3x3(vec1, normal, prod);
    rotmat = transpose(rotmat);

    // Convert rotation matrix to quaternion (R)
    float4 R = q_normalize(float4(rotmat[0][0], rotmat[0][1], rotmat[0][2], 0.0));
    RBuffer[id.x] = R;

    // Calculate area and edge lengths for scaling factor (k)
    float area = length(cross(v1 - v0, v2 - v0));
    float vec3_length = length(v2 - v1);
    float h = area / vec3_length;

    float k = (h + vec3_length) / (2.0 * MAX_SCALE);
    kBuffer[id.x] = k;
}

// Kernel: Map Gaussian attributes and update positions
[numthreads(64, 1, 1)]
void MapGaussiansToFaces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GaussianToFaceBuffer.Length)
        return;

    // Get the face index corresponding to this Gaussian
    int faceIndex = GaussianToFaceBuffer[id.x];

    // Map T, R, k for this Gaussian
    // float3 T = TBuffer[faceIndex];
    // float4 R = RBuffer[faceIndex];
    // float k = kBuffer[faceIndex];
    float3 T = TBuffer[id.x];
    float4 R = RBuffer[id.x];
    float k = kBuffer[id.x];
    // Normalize rotation and compute rigid rotation
    float4 originalRotation = HahaRotationBuffer[id.x];
    originalRotation = q_normalize(originalRotation);
    float4 rigidRotation = q_normalize(float4(
        R.w * originalRotation.x + R.x * originalRotation.w + R.y * originalRotation.z - R.z * originalRotation.y,
        R.w * originalRotation.y - R.x * originalRotation.z + R.y * originalRotation.w + R.z * originalRotation.x,
        R.w * originalRotation.z + R.x * originalRotation.y - R.y * originalRotation.x + R.z * originalRotation.w,
        R.w * originalRotation.w - R.x * originalRotation.x - R.y * originalRotation.y - R.z * originalRotation.z
    ));

    float3 scaling = HahaScalingBuffer[id.x];
    float3 adjustedScaling = s_act(scaling) * k;

    // Compute updated position
    float3 originalXyz = HahaXyzBuffer[id.x];
    float3 updatedXyz = T + quaternion_apply(rigidRotation, originalXyz) * adjustedScaling;

    // Write to combined buffer
    GaussianData data;
    data.rotation = rigidRotation;
    data.scaling = adjustedScaling;
    GaussianDataBuffer[id.x] = data;

    // Write updated position
    UpdatedXyzBuffer[id.x] = updatedXyz;
}
