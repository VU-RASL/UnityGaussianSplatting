#include "Quaternion.hlsl"
#pragma kernel CalcFacesTransform
#pragma kernel MapGaussiansToFaces

// Constants for scaling activation
#define MIN_S_VALUE 0.0f
#define MAX_S_VALUE 0.1f

// Buffers
StructuredBuffer<float3> VertexBuffer;       // Vertex positions
StructuredBuffer<int3> FaceBuffer;          // Faces (indices of vertices)
StructuredBuffer<int> GaussianToFaceBuffer; // Mapping from Gaussian to face indices
StructuredBuffer<float3> HahaXyzBuffer;     // Original Gaussian positions
StructuredBuffer<float4> HahaRotationBuffer; // Original Gaussian rotations
StructuredBuffer<float> HahaScalingBuffer;  // Original Gaussian scaling
RWStructuredBuffer<float3> TBuffer;         // Translations (output)
RWStructuredBuffer<float4> RBuffer;         // Rotations as quaternions (output)
RWStructuredBuffer<float> kBuffer;          // Scaling factors (output)

// Combined Gaussian-specific buffer
struct GaussianData
{

    float4 rotation;    
    float3 scaling;      
};
RWStructuredBuffer<GaussianData> GaussianDataBuffer; // Combined buffer

RWStructuredBuffer<float3> UpdatedXyzBuffer;    // Updated Gaussian positions

// Constants
#define MAX_SCALE 0.05

// Scaling activation function
float3 s_act(float3 x)
{
    return MIN_S_VALUE + saturate(1.0 / (1.0 + exp(-x))) * (MAX_S_VALUE - MIN_S_VALUE);
}

// Kernel: Compute translations, rotations, and scaling factors for faces
[numthreads(64, 1, 1)]
void CalcFacesTransform(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= FaceBuffer.Length)
        return;

    // Load face vertex indices
    int3 face = FaceBuffer[id.x];
    // int faceIndex = GaussianToFaceBuffer[id.x];  // Map Gaussian to face index
    // int3 face = FaceBuffer[faceIndex];  
    // Get face vertices
    float3 v0 = VertexBuffer[face.x];
    float3 v1 = VertexBuffer[face.y];
    float3 v2 = VertexBuffer[face.z];

    // Calculate translation (T): Mean of vertices
    float3 T = (v0 + v1 + v2) / 3.0f;
    TBuffer[id.x] = T;

    // Calculate vectors for face edges
    // float3 vec1 = normalize(v1 - v0);
    // float3 vec2 = normalize(v2 - v0);
    float3 vec1 = v2 - v1;
    float3 vec2 = v0 - v1;
    float3 vec3 = v0 - v2;

    vec1.x *= -1;
    vec2.x *= -1;
    vec3.x *= -1;

    // Calculate normal and orthonormal basis
    float3 v12cross = cross(vec1,vec2);
    float3 norm = normalize(v12cross);
    vec1 = normalize(vec1);
    float3 prod = normalize(cross(vec1, norm));

    // Build rotation matrix
    float3x3 rotmat = float3x3(vec1, norm, prod);
    rotmat = transpose(rotmat);

    // Convert rotation matrix to quaternion (R)
    // float4 R = normalize(float4(rotmat[0][0], rotmat[0][1], rotmat[0][2], 0.0));
    float4 R = MatrixToQuaternion(rotmat);
    RBuffer[id.x] = R;

    // Calculate area and edge lengths for scaling factor (k)
    float area = length(v12cross);
    float vec3_length = length(vec3);
    float h = area / vec3_length;

    float k = (h + vec3_length) / (2.0 * MAX_SCALE);
    kBuffer[id.x] = k;
}

// Kernel: Map Gaussian attributes and update positions
[numthreads(64, 1, 1)]
void MapGaussiansToFaces(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= GaussianToFaceBuffer.Length)
        return;

    // Get the face index corresponding to this Gaussian
    int faceIndex = GaussianToFaceBuffer[id.x];

    // Map T, R, k for this Gaussian
    float3 T = TBuffer[faceIndex];
    float4 R = RBuffer[faceIndex];
    float k = kBuffer[faceIndex];
    // float3 T = TBuffer[id.x];
    // float4 R = RBuffer[id.x];
    // float k = kBuffer[id.x];

    // Normalize rotation and compute rigid rotation
    float3 gOffset = HahaXyzBuffer[id.x]; // gaussian position offset
    float4 gR = normalize(HahaRotationBuffer[id.x]); // gaussian rotation
    float3 gS = HahaScalingBuffer[id.x]; // gaussian scaling

    // Compute and write to buffers
    GaussianData data;
    float4 rot = qmul(R,gR);
    rot.x *= -1;
    rot.w *= -1;
    data.rotation = rot;
    data.scaling = s_act(gS) * k;

    GaussianDataBuffer[id.x] = data;

    float3 pos = T + rotate_vector(gOffset,R) * k;
    pos.x *= -1;
    UpdatedXyzBuffer[id.x] = pos;
}
